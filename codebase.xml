<?xml version="1.0" encoding="UTF-8"?>
<codebase>
  <info>
    <description>
      Each file includes prefixed line numbers for reference.
      These numbers are metadata for navigation only ‚Äî use them when identifying code regions,
      Do not include them in any source or patch code being provided to the user.
      Do reference the line numbers in coversation when it will help navigate the user to the code you want to draw their attention towards.
    </description>
    <generated>2025-11-08T04:57:33.677476Z</generated>
    <root>/home/vizion/Github/MediaMarks</root>
  </info>

  <tree>
  <folder name="patches" />
  <file name="apply-ai-change.py" path="apply-ai-change.py" lang="python" />
  <file name="background.js" path="background.js" lang="javascript" />
  <file name="contentScript.js" path="contentScript.js" lang="javascript" />
  <file name="contentStyles.css" path="contentStyles.css" lang="css" />
  <file name="gallery.css" path="gallery.css" lang="css" />
  <file name="gallery.html" path="gallery.html" lang="html" />
  <file name="gallery.js" path="gallery.js" lang="javascript" />
  <file name="generate_codebase_xml.py" path="generate_codebase_xml.py" lang="python" />
  <file name="index_repo.py" path="index_repo.py" lang="python" />
  <file name="manifest-chromium.json" path="manifest-chromium.json" lang="json" />
  <file name="manifest-firefox.json" path="manifest-firefox.json" lang="json" />
  <file name="package.json" path="package.json" lang="json" />
  <file name="popup.html" path="popup.html" lang="html" />
  <file name="popup.js" path="popup.js" lang="javascript" />
  <file name="server.js" path="server.js" lang="javascript" />
  <file name="setup-mediamarks-server.sh" path="setup-mediamarks-server.sh" lang="bash" />
  <folder name="patches">
    <file name="ai-changes.json" path="patches/ai-changes.json" lang="json" />
  </folder>
  </tree>

  <files>
    <file path="apply-ai-change.py" lang="python"><![CDATA[
   1 | #!/usr/bin/env python3
   2 | import json, os, re, difflib, shutil, sys, datetime, uuid
   3 | from difflib import SequenceMatcher
   4 | 
   5 | BACKUP_DIR = ".ai_backups"
   6 | HISTORY_DIR = ".ai_history"
   7 | HISTORY_FILE = os.path.join(HISTORY_DIR, "changes.json")
   8 | 
   9 | def timestamp():
  10 |     return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
  11 | 
  12 | def fuzzy_find_anchor(content, anchor, threshold=0.5):
  13 |     """Find approximate position of anchor text within file content."""
  14 |     if not anchor.strip():
  15 |         return None
  16 | 
  17 |     # Exact match first
  18 |     idx = content.find(anchor)
  19 |     if idx != -1:
  20 |         return idx + len(anchor)
  21 | 
  22 |     # Substring fuzzy search (sliding window)
  23 |     best_ratio = 0
  24 |     best_pos = None
  25 |     window_size = len(anchor)
  26 |     for i in range(0, len(content) - window_size):
  27 |         window = content[i:i+window_size]
  28 |         ratio = SequenceMatcher(None, anchor, window).ratio()
  29 |         if ratio > best_ratio:
  30 |             best_ratio = ratio
  31 |             best_pos = i
  32 |         if ratio >= threshold:
  33 |             return i + window_size
  34 | 
  35 |     # Log for debugging if nothing matched well
  36 |     if best_ratio > 0:
  37 |         print(f"‚ö†Ô∏è Closest match ({best_ratio:.2f}) near position {best_pos}")
  38 |     return None
  39 | 
  40 | 
  41 | def backup_file(path):
  42 |     os.makedirs(BACKUP_DIR, exist_ok=True)
  43 |     bname = os.path.basename(path)
  44 |     bid = uuid.uuid4().hex[:8]
  45 |     dest = os.path.join(BACKUP_DIR, f"{bname}.{bid}.bak")
  46 |     shutil.copy2(path, dest)
  47 |     return dest
  48 | 
  49 | def log_change(entry, backup_path):
  50 |     os.makedirs(HISTORY_DIR, exist_ok=True)
  51 |     log_entry = {
  52 |         "id": uuid.uuid4().hex[:8],
  53 |         "timestamp": timestamp(),
  54 |         "file": entry["file"],
  55 |         "action": entry.get("action"),
  56 |         "anchor": entry.get("anchor"),
  57 |         "backup": backup_path,
  58 |         "summary": entry.get("content", "")[:80].replace("\n", " ") + "..."
  59 |     }
  60 |     history = []
  61 |     if os.path.exists(HISTORY_FILE):
  62 |         with open(HISTORY_FILE, "r", encoding="utf-8") as f:
  63 |             history = json.load(f)
  64 |     history.append(log_entry)
  65 |     with open(HISTORY_FILE, "w", encoding="utf-8") as f:
  66 |         json.dump(history, f, indent=2)
  67 | 
  68 | def apply_patch(entry):
  69 |     file_path = entry["file"]
  70 |     action = entry.get("action", "append")
  71 |     content = entry.get("content", "")
  72 |     anchor = entry.get("anchor")
  73 | 
  74 |     if not os.path.exists(file_path):
  75 |         print(f"‚ö†Ô∏è  File not found: {file_path}")
  76 |         return
  77 | 
  78 |     backup_path = backup_file(file_path)
  79 |     with open(file_path, "r", encoding="utf-8") as f:
  80 |         original = f.read()
  81 | 
  82 |     new_content = original
  83 | 
  84 |     if action == "replace":
  85 |         pattern = re.compile(anchor, re.MULTILINE)
  86 |         new_content = pattern.sub(content, original)
  87 |         print(f"üîÅ Replaced text in {file_path}")
  88 | 
  89 |     elif action == "insert_after" and anchor:
  90 |         pos = fuzzy_find_anchor(original, anchor)
  91 |         if pos is None:
  92 |             print(f"‚ö†Ô∏è  Anchor not found: {anchor} in {file_path}")
  93 |             return
  94 |         new_content = original[:pos] + content + original[pos:]
  95 |         print(f"‚ûï Inserted content after '{anchor}' in {file_path}")
  96 | 
  97 |     elif action == "insert_before" and anchor:
  98 |         pos = fuzzy_find_anchor(original, anchor)
  99 |         if pos is None:
 100 |             print(f"‚ö†Ô∏è  Anchor not found: {anchor} in {file_path}")
 101 |             return
 102 |         new_content = original[:pos - len(anchor)] + content + original[pos - len(anchor):]
 103 |         print(f"üîº Inserted content before '{anchor}' in {file_path}")
 104 | 
 105 |     elif action == "append":
 106 |         new_content = original + "\n" + content
 107 |         print(f"üìé Appended content to {file_path}")
 108 | 
 109 |     elif action == "prepend":
 110 |         new_content = content + "\n" + original
 111 |         print(f"üìã Prepended content to {file_path}")
 112 | 
 113 |     with open(file_path, "w", encoding="utf-8") as f:
 114 |         f.write(new_content)
 115 | 
 116 |     log_change(entry, backup_path)
 117 | 
 118 | def main():
 119 |     if len(sys.argv) < 2:
 120 |         print("Usage: ./apply-ai-change.py <patch.json>")
 121 |         sys.exit(1)
 122 | 
 123 |     patch_file = sys.argv[1]
 124 |     with open(patch_file, "r", encoding="utf-8") as f:
 125 |         patches = json.load(f)
 126 | 
 127 |     for entry in patches:
 128 |         apply_patch(entry)
 129 | 
 130 |     print(f"‚úÖ Applied {len(patches)} change(s).")
 131 |     print(f"üóÉÔ∏è  Backups in '{BACKUP_DIR}/' | History logged at '{HISTORY_FILE}'")
 132 | 
 133 | if __name__ == "__main__":
 134 |     main()
]]></file>
    <file path="background.js" lang="javascript"><![CDATA[
   1 | // background.js (MV3 service worker)
   2 | 
   3 | const GALLERY_PATH = "gallery.html";const API_BASE = 'http://localhost:3000';
   4 | const USER_ID = 'default-user';
   5 | 
   6 | 
   7 | // Create context menu to save from linked images
   8 | chrome.runtime.onInstalled.addListener(() => {
   9 |   chrome.contextMenus.create({
  10 |     id: "vidtab-save-image-link",
  11 |     title: "Save to VidTab Gallery",
  12 |     contexts: ["image"]
  13 |   });
  14 | });
  15 | 
  16 | // Clicking the extension icon opens gallery
  17 | chrome.action.onClicked.addListener(openGalleryTab);
  18 | 
  19 | // Handle messages from popup or content script
  20 | chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
  21 |   if (msg?.type === "OPEN_GALLERY") {
  22 |     openGalleryTab().then(() => sendResponse({ ok: true }));
  23 |     return true; // keep port open for async
  24 |   }
  25 | 
  26 |   if (msg?.type === "SAVE_ITEM_FROM_CONTEXT") {
  27 |     addItem(msg.payload)
  28 |       .then(() => sendResponse({ ok: true }))
  29 |       .catch(e => sendResponse({ ok: false, error: String(e) }));
  30 |     return true; // keep port open for async
  31 |   }
  32 | });
  33 | 
  34 | // Context menu click handler
  35 | chrome.contextMenus.onClicked.addListener(async (info, tab) => {
  36 |   if (info.menuItemId !== "vidtab-save-image-link") return;
  37 | 
  38 |   const payload = {
  39 |     id: makeId(),
  40 |     url: info.linkUrl || info.pageUrl,
  41 |     img: info.srcUrl,
  42 |     title: tab?.title || info.linkUrl || info.pageUrl,
  43 |     sourcePageUrl: info.pageUrl,
  44 |     tags: [],
  45 |     createdAt: Date.now()
  46 |   };
  47 |   await addItem(payload);
  48 | });
  49 | 
  50 | function makeId() {
  51 |   return `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  52 | }
  53 | 
  54 | async function addItem(item) {
  55 |   const data = await chrome.storage.local.get({ items: [] });
  56 |   const items = data.items;
  57 | 
  58 |   // Prevent duplicates
  59 |   if (!items.some(x => x.url === item.url && x.img === item.img)) {
  60 |     items.unshift(item);
  61 |     await chrome.storage.local.set({ items });  // Persist the item remotely for cross‚Äëdevice synchronisation.
  62 |   sendItemToServer(item).catch(err => console.error(err));
  63 |   }
  64 | }
  65 | 
  66 | async function openGalleryTab() {
  67 |   const url = chrome.runtime.getURL(GALLERY_PATH);
  68 |   const tabs = await chrome.tabs.query({ url });
  69 | 
  70 |   if (tabs.length > 0) {
  71 |     await chrome.tabs.update(tabs[0].id, { active: true });
  72 |   } else {
  73 |     await chrome.tabs.create({ url });
  74 |   }
  75 | }
  76 | 
  77 | 
  78 | /**
  79 |  * Send a bookmark to the backend API. The server will upsert the record based on the item id and user_id.
  80 |  * Any network errors are logged but do not prevent local storage from being updated.
  81 |  */
  82 | async function sendItemToServer(item) {
  83 |   const payload = { ...item, user_id: USER_ID };
  84 |   try {
  85 |     await fetch(`${API_BASE}/bookmarks`, {
  86 |       method: 'POST',
  87 |       headers: { 'Content-Type': 'application/json' },
  88 |       body: JSON.stringify(payload)
  89 |     });
  90 |   } catch (err) {
  91 |     console.error('Failed to sync item to server', err);
  92 |   }
  93 | }
  94 | 
  95 | /**
  96 |  * Fetch all bookmarks for this user from the backend and merge them into local storage.
  97 |  * New items from the server are appended to the local collection. Existing items are left untouched.
  98 |  */
  99 | async function syncFromServer() {
 100 |   try {
 101 |     const res = await fetch(`${API_BASE}/bookmarks?user_id=${encodeURIComponent(USER_ID)}`);
 102 |     const data = await res.json();
 103 |     const remoteItems = data.items || [];
 104 |     const localData = await chrome.storage.local.get({ items: [] });
 105 |     const localItems = localData.items;
 106 |     let changed = false;
 107 |     remoteItems.forEach(remote => {
 108 |       if (!localItems.some(local => local.id === remote.id)) {
 109 |         localItems.push(remote);
 110 |         changed = true;
 111 |       }
 112 |     });
 113 |     if (changed) {
 114 |       await chrome.storage.local.set({ items: localItems });
 115 |     }
 116 |   } catch (err) {
 117 |     console.error('Failed to sync bookmarks from server', err);
 118 |   }
 119 | }
 120 | 
 121 | // Kick off a sync when the extension is installed or the browser starts.
 122 | chrome.runtime.onInstalled.addListener(() => {
 123 |   syncFromServer();
 124 | });
 125 | 
 126 | chrome.runtime.onStartup.addListener(() => {
 127 |   syncFromServer();
 128 | });
]]></file>
    <file path="contentScript.js" lang="javascript"><![CDATA[
   1 | // Inject "+ Save" button on hover for linked images
   2 | const BTN_CLASS = "vv-save-btn";
   3 | const WRAP_CLASS = "vv-rel";
   4 | const HOVER_CLASS = "vv-hover";
   5 | const processedAnchors = new WeakSet();
   6 | const MEDIA_SELECTOR = "img, picture img, video";
   7 | const DATA_ATTRS = ["data-img-url", "data-thumbnail-url", "data-thumb", "data-src", "data-lazy-src", "data-original"];
   8 | const DATA_ATTR_SELECTOR = DATA_ATTRS.map(attr => `[${attr}]`).join(",");
   9 | const BACKGROUND_SCAN_LIMIT = 12;
  10 | let toastEl = null;
  11 | 
  12 | init();
  13 | 
  14 | function init() {
  15 |   injectToast();
  16 |   hydrateExistingAnchors(document);
  17 |   observeMutations();
  18 | }
  19 | 
  20 | function observeMutations() {
  21 |   const obs = new MutationObserver(mutations => {
  22 |     for (const mutation of mutations) {
  23 |       if (mutation.type === "childList" && mutation.target.nodeType === Node.ELEMENT_NODE) {
  24 |         const targetEl = mutation.target;
  25 |         if (targetEl.matches?.("a[href]")) {
  26 |           processAnchor(targetEl);
  27 |         } else {
  28 |           const ancestorAnchor = targetEl.closest?.("a[href]");
  29 |           if (ancestorAnchor) processAnchor(ancestorAnchor);
  30 |         }
  31 |       }
  32 | 
  33 |       mutation.addedNodes.forEach(node => {
  34 |         if (node.nodeType !== Node.ELEMENT_NODE) return;
  35 |         hydrateExistingAnchors(node);
  36 |       });
  37 |     }
  38 |   });
  39 |   obs.observe(document.documentElement, { childList: true, subtree: true });
  40 | }
  41 | 
  42 | function hydrateExistingAnchors(root) {
  43 |   if (root.matches?.("a[href]")) {
  44 |     processAnchor(root);
  45 |   }
  46 | 
  47 |   root.querySelectorAll?.("a[href]").forEach(processAnchor);
  48 | }
  49 | 
  50 | function processAnchor(anchor) {
  51 |   if (!anchor.isConnected || processedAnchors.has(anchor)) return;
  52 | 
  53 |   const media = findMediaElement(anchor);
  54 |   if (!media) return;
  55 | 
  56 |   processedAnchors.add(anchor);
  57 | 
  58 |   ensureRelativePosition(anchor);
  59 |   anchor.classList.add(HOVER_CLASS);
  60 | 
  61 |   const btn = buildButton(anchor, media);
  62 |   anchor.appendChild(btn);
  63 | }
  64 | 
  65 | function findMediaElement(anchor) {
  66 |   const media = anchor.querySelector(MEDIA_SELECTOR);
  67 |   if (media) return media;
  68 | 
  69 |   const dataNode = findDataAttrNode(anchor);
  70 |   if (dataNode) {
  71 |     return dataNode;
  72 |   }
  73 | 
  74 |   const backgroundNode = findBackgroundImageNode(anchor);
  75 |   if (backgroundNode) return backgroundNode;
  76 | 
  77 |   return null;
  78 | }
  79 | 
  80 | function findDataAttrNode(anchor) {
  81 |   for (const attr of DATA_ATTRS) {
  82 |     if (anchor.hasAttribute(attr)) return anchor;
  83 |   }
  84 |   if (!DATA_ATTR_SELECTOR) return null;
  85 |   return anchor.querySelector(DATA_ATTR_SELECTOR);
  86 | }
  87 | 
  88 | function findBackgroundImageNode(anchor) {
  89 |   const candidates = [anchor, ...anchor.querySelectorAll("*")];
  90 |   for (let i = 0; i < candidates.length && i < BACKGROUND_SCAN_LIMIT; i++) {
  91 |     const node = candidates[i];
  92 |     if (!(node instanceof Element)) continue;
  93 | 
  94 |     if (node.style?.backgroundImage && node.style.backgroundImage !== "none") {
  95 |       return node;
  96 |     }
  97 | 
  98 |     const computed = window.getComputedStyle(node);
  99 |     if (computed.backgroundImage && computed.backgroundImage !== "none") {
 100 |       return node;
 101 |     }
 102 |   }
 103 |   return null;
 104 | }
 105 | 
 106 | function ensureRelativePosition(anchor) {
 107 |   const computed = window.getComputedStyle(anchor);
 108 |   if (computed.position === "static") {
 109 |     anchor.classList.add(WRAP_CLASS);
 110 |   }
 111 | }
 112 | 
 113 | function buildButton(anchor, media) {
 114 |   const btn = document.createElement("span");
 115 |   btn.className = BTN_CLASS;
 116 |   btn.setAttribute("role", "button");
 117 |   btn.tabIndex = 0;
 118 |   btn.textContent = "Ôºã Save";
 119 |   btn.title = "Save to VidTab Gallery";
 120 | 
 121 |   const activate = async (event) => {
 122 |     event.preventDefault();
 123 |     event.stopPropagation();
 124 | 
 125 |     const url = absolutizeUrl(anchor.getAttribute("href") || anchor.href);
 126 |     const img = resolveMediaUrl(media);
 127 | 
 128 |     if (!url || !img) {
 129 |       showToast("Couldn‚Äôt detect link or image to save.");
 130 |       return;
 131 |     }
 132 | 
 133 |     const payload = {
 134 |       id: makeId(),
 135 |       url,
 136 |       img,
 137 |       title: getTitle(media, anchor, url),
 138 |       sourcePageUrl: location.href,
 139 |       tags: [],
 140 |       createdAt: Date.now()
 141 |     };
 142 | 
 143 |     try {
 144 |       await chrome.runtime.sendMessage({ type: "SAVE_ITEM_FROM_CONTEXT", payload });
 145 |       showToast("Saved to VidTab Gallery ‚úîÔ∏è");
 146 |     } catch (err) {
 147 |       showToast("Couldn‚Äôt save. Check extension permissions.");
 148 |       console.error(err);
 149 |     }
 150 |   };
 151 | 
 152 |   btn.addEventListener("click", activate);
 153 |   btn.addEventListener("keydown", e => {
 154 |     if (e.key === "Enter" || e.key === " ") {
 155 |       e.preventDefault();
 156 |       activate(e);
 157 |     }
 158 |   });
 159 | 
 160 |   return btn;
 161 | }
 162 | 
 163 | function resolveMediaUrl(media) {
 164 |   if (!media) return null;
 165 | 
 166 |   // If we fabricated a ghost <img>, just take its src directly.
 167 |   if (!media.isConnected && media.tagName === "IMG") {
 168 |     return absolutizeUrl(media.src);
 169 |   }
 170 | 
 171 |   if ("currentSrc" in media && media.currentSrc) {
 172 |     return absolutizeUrl(media.currentSrc);
 173 |   }
 174 | 
 175 |   if ("src" in media && media.src) {
 176 |     return absolutizeUrl(media.src);
 177 |   }
 178 | 
 179 |   if (media.tagName === "VIDEO") {
 180 |     const poster = media.getAttribute("poster");
 181 |     if (poster) return absolutizeUrl(poster);
 182 |   }
 183 | 
 184 |   const dataSrcAttr = ["data-src", "data-lazy-src", "data-original", "data-thumb", "data-thumbnail-url"];
 185 |   for (const attr of dataSrcAttr) {
 186 |     const val = media.getAttribute?.(attr);
 187 |     if (val) return absolutizeUrl(val);
 188 |   }
 189 | 
 190 |   const bgImage = window.getComputedStyle(media).backgroundImage;
 191 |   if (bgImage && bgImage !== "none") {
 192 |     const match = bgImage.match(/url\((["']?)(.*?)\1\)/);
 193 |     if (match && match[2]) {
 194 |       return absolutizeUrl(match[2]);
 195 |     }
 196 |   }
 197 | 
 198 |   return null;
 199 | }
 200 | 
 201 | function getTitle(media, anchor, fallbackUrl) {
 202 |   return (
 203 |     media.getAttribute?.("alt") ||
 204 |     media.getAttribute?.("aria-label") ||
 205 |     anchor.getAttribute("title") ||
 206 |     anchor.textContent?.trim() ||
 207 |     document.title ||
 208 |     fallbackUrl
 209 |   );
 210 | }
 211 | 
 212 | function absolutizeUrl(u) {
 213 |   if (!u) return null;
 214 |   try {
 215 |     return new URL(u, location.href).toString();
 216 |   } catch {
 217 |     return u;
 218 |   }
 219 | }
 220 | 
 221 | function makeId() {
 222 |   return `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
 223 | }
 224 | 
 225 | function injectToast() {
 226 |   if (toastEl) return;
 227 |   toastEl = document.createElement("div");
 228 |   toastEl.id = "vv-toast";
 229 |   document.documentElement.appendChild(toastEl);
 230 | }
 231 | 
 232 | function showToast(msg, ms = 1800) {
 233 |   if (!toastEl) injectToast();
 234 |   toastEl.textContent = msg;
 235 |   toastEl.classList.add("show");
 236 |   setTimeout(() => toastEl && toastEl.classList.remove("show"), ms);
 237 | }
]]></file>
    <file path="contentStyles.css" lang="css"><![CDATA[
   1 | /* Overlay button */
   2 | .vv-rel { position: relative; }
   3 | .vv-hover:hover .vv-save-btn,
   4 | .vv-hover:focus-within .vv-save-btn {
   5 |   opacity: 1;
   6 | }
   7 | .vv-save-btn {
   8 |   position: absolute;
   9 |   top: 6px;
  10 |   right: 6px;
  11 |   z-index: 2147483647;
  12 |   padding: 4px 6px;
  13 |   border-radius: 4px;
  14 |   font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  15 |   background: rgba(0,0,0,0.75);
  16 |   color: #fff;
  17 |   border: 1px solid rgba(255,255,255,0.2);
  18 |   cursor: pointer;
  19 |   opacity: 0;
  20 |   transition: opacity .15s ease;
  21 |   display: inline-flex;
  22 |   align-items: center;
  23 |   gap: 4px;
  24 | }
  25 | .vv-save-btn:focus-visible {
  26 |   opacity: 1;
  27 |   outline: 2px solid #3ea6ff;
  28 |   outline-offset: 2px;
  29 | }
  30 | #vv-toast {
  31 |   position: fixed;
  32 |   bottom: 18px;
  33 |   right: 18px;
  34 |   background: #111;
  35 |   color: #fff;
  36 |   padding: 10px 12px;
  37 |   border-radius: 6px;
  38 |   box-shadow: 0 6px 16px rgba(0,0,0,.25);
  39 |   font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  40 |   z-index: 2147483647;
  41 |   display: none;
  42 | }
  43 | #vv-toast.show { display: block; }
]]></file>
    <file path="gallery.css" lang="css"><![CDATA[
   1 | :root {
   2 |   --bg: #0b0d10;
   3 |   --panel: #12161b;
   4 |   --muted: #9aa4af;
   5 |   --text: #e8edf2;
   6 |   --accent: #3ea6ff;
   7 |   --danger: #ff5d6c;
   8 |   --ok: #37d67a;
   9 |   --border: #243040;
  10 | }
  11 | 
  12 | * { box-sizing: border-box; }
  13 | html, body { height: 100%; }
  14 | body {
  15 |   margin: 0;
  16 |   font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  17 |   color: var(--text);
  18 |   background: radial-gradient(1200px 600px at 100% -5%, #131a22, #0b0d10);
  19 | }
  20 | 
  21 | .topbar {
  22 |   display: flex;
  23 |   align-items: center;
  24 |   justify-content: space-between;
  25 |   padding: 14px 18px;
  26 |   border-bottom: 1px solid var(--border);
  27 |   background: rgba(0,0,0,0.35);
  28 |   backdrop-filter: blur(6px);
  29 |   position: sticky;
  30 |   top: 0;
  31 |   z-index: 5;
  32 | }
  33 | .topbar h1 {
  34 |   margin: 0;
  35 |   font-size: 18px;
  36 |   letter-spacing: .2px;
  37 | }
  38 | .topbar .actions {
  39 |   display: flex;
  40 |   gap: 10px;
  41 |   align-items: center;
  42 | }
  43 | 
  44 | .control-panel {
  45 |   padding: 12px 18px;
  46 |   background: var(--panel);
  47 |   border-bottom: 1px solid var(--border);
  48 |   display: grid;
  49 |   gap: 8px;
  50 | }
  51 | 
  52 | .control-panel[hidden] {
  53 |   display: none !important;
  54 | }
  55 | .panel-actions {
  56 |   display: flex;
  57 |   justify-content: flex-end;
  58 |   gap: 8px;
  59 |   margin-top: 4px;
  60 | }
  61 | input[type="search"], input[type="text"] {
  62 |   background: var(--panel);
  63 |   border: 1px solid var(--border);
  64 |   color: var(--text);
  65 |   padding: 8px 10px;
  66 |   border-radius: 6px;
  67 |   min-width: 280px;
  68 |   outline: none;
  69 | }
  70 | button {
  71 |   appearance: none;
  72 |   background: var(--panel);
  73 |   color: var(--text);
  74 |   border: 1px solid var(--border);
  75 |   padding: 8px 10px;
  76 |   border-radius: 6px;
  77 |   cursor: pointer;
  78 | }
  79 | button:hover { border-color: var(--accent); }
  80 | 
  81 | main {
  82 |   display: grid;
  83 |   grid-template-columns: 220px 1fr;
  84 |   gap: 14px;
  85 |   padding: 16px;
  86 | }
  87 | 
  88 | .sidebar {
  89 |   border: 1px solid var(--border);
  90 |   border-radius: 10px;
  91 |   padding: 12px;
  92 |   background: rgba(18,22,27,0.8);
  93 | }
  94 | .sidebar h2 {
  95 |   margin-top: 0;
  96 |   font-size: 14px;
  97 |   color: var(--muted);
  98 | }
  99 | .tag-cloud { display: flex; flex-wrap: wrap; gap: 8px; }
 100 | .tag-cloud .tag {
 101 |   padding: 4px 8px;
 102 |   background: #16202b;
 103 |   border: 1px solid var(--border);
 104 |   border-radius: 999px;
 105 |   color: var(--muted);
 106 |   cursor: pointer;
 107 | }
 108 | .tag.active { color: #fff; border-color: var(--accent); }
 109 | 
 110 | .grid {
 111 |   display: grid;
 112 |   grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
 113 |   gap: 14px;
 114 | }
 115 | 
 116 | .card {
 117 |   background: rgba(18,22,27,0.8);
 118 |   border: 1px solid var(--border);
 119 |   border-radius: 10px;
 120 |   overflow: hidden;
 121 |   display: flex;
 122 |   flex-direction: column;
 123 | }
 124 | 
 125 | /* small tweak for bookmark cards */
 126 | .card .thumb {
 127 |   display: block;
 128 |   background: #000;
 129 |   aspect-ratio: 16 / 9;
 130 |   overflow: hidden;
 131 |   position: relative;
 132 | }
 133 | .card .thumb img {
 134 |   width: 100%;
 135 |   height: 100%;
 136 |   object-fit: cover;
 137 | }
 138 | .meta { padding: 10px; display: grid; gap: 8px; }
 139 | .meta .row {
 140 |   display: flex;
 141 |   align-items: center;
 142 |   justify-content: space-between;
 143 |   gap: 8px;
 144 | }
 145 | .meta .link {
 146 |   color: var(--muted);
 147 |   text-decoration: none;
 148 |   overflow: hidden;
 149 |   text-overflow: ellipsis;
 150 |   white-space: nowrap;
 151 |   max-width: 60%;
 152 | }
 153 | .buttons { display: flex; gap: 6px; }
 154 | button.save { border-color: #2b7a47; }
 155 | button.save:hover { background: rgba(55,214,122,0.1); }
 156 | button.delete { border-color: #7a2b35; color: #ff96a1; }
 157 | button.delete:hover { background: rgba(255,93,108,0.08); }
 158 | 
 159 | .tab { background: transparent; border: 1px solid var(--border); padding:6px 8px; border-radius:6px; cursor:pointer; color:var(--muted); }
 160 | .tab.active { color:var(--text); border-color:var(--accent); }
 161 | 
 162 | /* Modal */
 163 | .modal { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(2,6,10,0.6); z-index:9999; }
 164 | .modal-inner { width:480px; max-width:94%; background:var(--panel); border:1px solid var(--border); padding:14px; border-radius:10px; }
 165 | .modal-inner h3 { margin:0 0 8px 0; }
 166 | .modal-inner label { display:block; margin-bottom:8px; color:var(--muted); }
 167 | .modal-inner input[type="text"], .modal-inner input[type="url"] { width:100%; padding:8px; border-radius:6px; border:1px solid var(--border); background:transparent; color:var(--text); }
]]></file>
    <file path="gallery.html" lang="html"><![CDATA[
   1 | <!doctype html>
   2 | <html lang="en">
   3 | <head>
   4 | <meta charset="utf-8" />
   5 | <title>VidTab Gallery</title>
   6 | <meta name="viewport" content="width=device-width, initial-scale=1" />
   7 | <link rel="stylesheet" href="gallery.css" />
   8 | </head>
   9 | <body>
  10 | <header class="topbar">
  11 |   <h1>VidTab Gallery</h1>
  12 |   <div class="actions">
  13 |     <input id="search" type="search" placeholder="Search title, URL, or tags‚Ä¶" />
  14 |     <button id="add-manual" title="Add a manual entry">Add Entry</button>
  15 |     <button id="edit-mode" title="Batch edit">Edit</button>
  16 |     <button id="delete-mode" title="Batch delete">Delete</button>
  17 |     <button id="clear-all"
  18 |     <button id="export-btn" title="Export bookmarks">Export</button>
  19 |     <input id="import-btn" type="file" accept="application/json" title="Import bookmarks" />
  20 |  title="Remove everything">Clear All</button>
  21 |   </div>
  22 | </header>
  23 | <section id="manual-add-panel" class="control-panel" hidden>
  24 |   <input id="manual-url" type="text" placeholder="Video URL" />
  25 |   <input id="manual-img" type="text" placeholder="Image URL (thumbnail)" />
  26 |   <input id="manual-title" type="text" placeholder="Title (optional)" />
  27 |   <input id="manual-tags" type="text" placeholder="Comma,separated,tags (optional)" />
  28 |   <div class="panel-actions">
  29 |     <button type="button" id="cancel-manual">Cancel</button>
  30 |   </div>
  31 | </section>
  32 | 
  33 | <section id="global-edit-panel" class="control-panel" hidden>
  34 |   <input id="global-title" type="text" placeholder="New title (optional)" />
  35 |   <input id="global-img" type="text" placeholder="Thumbnail URL (optional)" />
  36 |   <input id="global-tags" type="text" placeholder="Comma,separated,tags (optional)" />
  37 |   <div class="panel-actions">
  38 |     <button type="button" id="cancel-edit">Cancel</button>
  39 |   </div>
  40 | </section>
  41 | 
  42 | <main>
  43 |   <aside class="sidebar">
  44 |     <h2>Tags</h2>
  45 |     <div id="tag-cloud" class="tag-cloud"></div>
  46 |   </aside>
  47 |   <section class="grid" id="grid"></section>
  48 | </main>
  49 | 
  50 | <template id="card-tpl">
  51 |   <article class="card">
  52 |     <a class="thumb" target="_blank" rel="noreferrer noopener">
  53 |       <img loading="lazy" alt="" />
  54 |     </a>
  55 |     <div class="meta">
  56 |       <div class="title"></div>
  57 |       <div class="row">
  58 |         <a class="link" target="_blank" rel="noreferrer noopener"></a>
  59 |       </div>
  60 |     </div>
  61 |   </article>
  62 | </template>
  63 | 
  64 | <script src="gallery.js"></script>
  65 | </body>
  66 | </html>
]]></file>
    <file path="gallery.js" lang="javascript"><![CDATA[
   1 | const grid = document.getElementById("grid");
   2 | const searchInput = document.getElementById("search");
   3 | const clearAllBtn = document.getElementById("clear-all");
   4 | const tagCloud = document.getElementById("tag-cloud");
   5 | const cardTpl = document.getElementById("card-tpl");
   6 | 
   7 | const editModeBtn = document.getElementById("edit-mode");
   8 | const deleteModeBtn = document.getElementById("delete-mode");
   9 | const manualPanel = document.getElementById("manual-add-panel");
  10 | const globalEditPanel = document.getElementById("global-edit-panel");
  11 | const globalImg = document.getElementById("global-img");
  12 | const globalTitle = document.getElementById("global-title");
  13 | const globalTags = document.getElementById("global-tags");
  14 | 
  15 | const manualUrl = document.getElementById("manual-url");
  16 | const manualImg = document.getElementById("manual-img");
  17 | const manualTitle = document.getElementById("manual-title");
  18 | const manualTags = document.getElementById("manual-tags");
  19 | const addManualBtn = document.getElementById("add-manual");
  20 | const cancelManualBtn = document.getElementById("cancel-manual");
  21 | const cancelEditBtn = document.getElementById("cancel-edit");
  22 | 
  23 | let items = [];
  24 | let activeTag = null;
  25 | let searchTerm = "";
  26 | let batchMode = null; // "edit" | "delete" | null
  27 | let manualPanelOpen = false;
  28 | let editPanelOpen = false;
  29 | 
  30 | (async function init() {
  31 |   await loadItems();
  32 |   renderAll();
  33 |   manualPanel.hidden = true;
  34 |   globalEditPanel.hidden = true;
  35 | 
  36 |   searchInput.addEventListener("input", () => {
  37 |     searchTerm = searchInput.value.trim().toLowerCase();
  38 |     renderAll();
  39 |   });
  40 | 
  41 |   clearAllBtn.addEventListener("click", async () => {
  42 |     if (!confirm("Delete ALL saved items? This cannot be undone.")) return;
  43 |     items = [];
  44 |     await chrome.storage.local.set({ items });
  45 |     renderAll();
  46 |   });
  47 | 
  48 |   editModeBtn.addEventListener("click", async () => {
  49 |     if (!editPanelOpen) {
  50 |       if (manualPanelOpen) {
  51 |         closeManualPanel();
  52 |       }
  53 |       if (batchMode === "delete") {
  54 |         batchMode = null;
  55 |         renderAll();
  56 |       }
  57 |       batchMode = "edit";
  58 |       editPanelOpen = true;
  59 |       globalEditPanel.hidden = false;
  60 |       editModeBtn.textContent = "Submit";
  61 |       renderAll();
  62 |       globalTitle.focus();
  63 |       return;
  64 |     }
  65 | 
  66 |     const checked = getCheckedIds();
  67 |     if (!checked.length) {
  68 |       alert("Select at least one item to update.");
  69 |       return;
  70 |     }
  71 | 
  72 |     const titleVal = globalTitle.value.trim();
  73 |     const imgVal = globalImg.value.trim();
  74 |     const tagsVal = parseTags(globalTags.value);
  75 | 
  76 |     items = items.map(it => {
  77 |       if (checked.includes(it.id)) {
  78 |         return {
  79 |           ...it,
  80 |           title: titleVal || it.title,
  81 |           img: imgVal || it.img,
  82 |           tags: tagsVal.length ? Array.from(new Set([...(it.tags || []), ...tagsVal])) : it.tags
  83 |         };
  84 |       }
  85 |       return it;
  86 |     });
  87 |     await chrome.storage.local.set({ items });
  88 | 
  89 |     closeEditPanel();
  90 |     renderAll();
  91 |   });
  92 | 
  93 |   deleteModeBtn.addEventListener("click", async () => {
  94 |     if (batchMode === "delete") {
  95 |       const checked = getCheckedIds();
  96 |       if (checked.length && confirm(`Delete ${checked.length} items?`)) {
  97 |         items = items.filter(it => !checked.includes(it.id));
  98 |         await chrome.storage.local.set({ items });
  99 |       }
 100 |       batchMode = null;
 101 |       renderAll();
 102 |     } else {
 103 |       if (editPanelOpen) {
 104 |         closeEditPanel();
 105 |       }
 106 |       if (manualPanelOpen) {
 107 |         closeManualPanel();
 108 |       }
 109 |       batchMode = "delete";
 110 |       renderAll();
 111 |     }
 112 |   });
 113 | 
 114 |   addManualBtn.addEventListener("click", async () => {
 115 |     if (!manualPanelOpen) {
 116 |       if (editPanelOpen) {
 117 |         closeEditPanel();
 118 |         renderAll();
 119 |       } else if (batchMode === "delete") {
 120 |         batchMode = null;
 121 |         renderAll();
 122 |       }
 123 |       manualPanel.hidden = false;
 124 |       manualPanelOpen = true;
 125 |       addManualBtn.textContent = "Submit";
 126 |       manualUrl.focus();
 127 |       return;
 128 |     }
 129 | 
 130 |     const url = manualUrl.value.trim();
 131 |     const img = manualImg.value.trim();
 132 |     if (!url || !img) {
 133 |       alert("Both Video URL and Image URL are required.");
 134 |       return;
 135 |     }
 136 | 
 137 |     const payload = {
 138 |       id: makeId(),
 139 |       url,
 140 |       img,
 141 |       title: manualTitle.value.trim() || url,
 142 |       tags: parseTags(manualTags.value),
 143 |       sourcePageUrl: url,
 144 |       createdAt: Date.now()
 145 |     };
 146 | 
 147 |     // Save
 148 |     items.unshift(payload);
 149 |     await chrome.storage.local.set({ items });
 150 | 
 151 |     // Reset form / close panel
 152 |     closeManualPanel();
 153 | 
 154 |     renderAll();
 155 |   });
 156 | 
 157 |   cancelManualBtn.addEventListener("click", () => {
 158 |     if (!manualPanelOpen) return;
 159 |     closeManualPanel();
 160 |   });
 161 | 
 162 |   cancelEditBtn.addEventListener("click", () => {
 163 |     if (!editPanelOpen) return;
 164 |     closeEditPanel();
 165 |     renderAll();
 166 |   });
 167 | 
 168 |   chrome.storage.onChanged.addListener((changes, area)
 169 |   // Initialise import/export buttons if they exist in the gallery HTML.
 170 |   const exportBtn = document.getElementById('export-btn');
 171 |   const importInput = document.getElementById('import-btn');
 172 |   if (exportBtn) {
 173 |     exportBtn.addEventListener('click', async () => {
 174 |       const data = await chrome.storage.local.get({ items: [] });
 175 |       const blob = new Blob([JSON.stringify(data.items, null, 2)], { type: 'application/json' });
 176 |       const url = URL.createObjectURL(blob);
 177 |       const a = document.createElement('a');
 178 |       a.href = url;
 179 |       a.download = 'mediamarks-backup.json';
 180 |       a.style.display = 'none';
 181 |       document.body.appendChild(a);
 182 |       a.click();
 183 |       document.body.removeChild(a);
 184 |       URL.revokeObjectURL(url);
 185 |     });
 186 |   }
 187 |   if (importInput) {
 188 |     importInput.addEventListener('change', async (event) => {
 189 |       const file = event.target.files[0];
 190 |       if (!file) return;
 191 |       const text = await file.text();
 192 |       try {
 193 |         const imported = JSON.parse(text);
 194 |         if (!Array.isArray(imported)) {
 195 |           alert('Imported file does not contain an array of bookmarks.');
 196 |           return;
 197 |         }
 198 |         const data = await chrome.storage.local.get({ items: [] });
 199 |         const localItems = data.items;
 200 |         let changed = false;
 201 |         imported.forEach(item => {
 202 |           if (!localItems.some(x => x.id === item.id)) {
 203 |             localItems.push(item);
 204 |             changed = true;
 205 |           }
 206 |         });
 207 |         if (changed) {
 208 |           await chrome.storage.local.set({ items: localItems });
 209 |           renderAll();
 210 |         }
 211 |         event.target.value = '';
 212 |         alert(`${imported.length} bookmarks imported`);
 213 |       } catch (err) {
 214 |         console.error(err);
 215 |         alert('Failed to import bookmarks: ' + err.message);
 216 |       }
 217 |     });
 218 |   }
 219 |  => {
 220 |     if (area === "local" && changes.items) {
 221 |       items = changes.items.newValue || [];
 222 |       renderAll();
 223 |     }
 224 |   });
 225 | })();
 226 | 
 227 | async function loadItems() {
 228 |   const data = await chrome.storage.local.get({ items: [] });
 229 |   items = data.items;
 230 | }
 231 | 
 232 | function renderAll() {
 233 |   const filtered = filterItems(items, searchTerm, activeTag);
 234 |   renderTagCloud(items, activeTag);
 235 |   renderGrid(filtered);
 236 | }
 237 | 
 238 | function filterItems(list, term, tag) {
 239 |   return list.filter(it => {
 240 |     const hitTag = tag ? (it.tags || []).map(t => t.toLowerCase()).includes(tag.toLowerCase()) : true;
 241 |     const hay = `${it.title} ${it.url} ${(it.tags || []).join(" ")}`.toLowerCase();
 242 |     const hitTerm = term ? hay.includes(term) : true;
 243 |     return hitTag && hitTerm;
 244 |   });
 245 | }
 246 | 
 247 | function renderTagCloud(list, active) {
 248 |   const counts = new Map();
 249 |   list.forEach(it => (it.tags || []).forEach(t => counts.set(t, (counts.get(t) || 0) + 1)));
 250 | 
 251 |   tagCloud.innerHTML = "";
 252 |   const all = document.createElement("span");
 253 |   all.className = `tag ${active ? "" : "active"}`;
 254 |   all.textContent = "All";
 255 |   all.title = "Show all items";
 256 |   all.addEventListener("click", () => {
 257 |     activeTag = null;
 258 |     renderAll();
 259 |   });
 260 |   tagCloud.appendChild(all);
 261 | 
 262 |   Array.from(counts.entries())
 263 |     .sort((a, b) => b[1] - a[1])
 264 |     .slice(0, 100)
 265 |     .forEach(([tag, count]) => {
 266 |       const span = document.createElement("span");
 267 |       span.className = `tag ${active === tag ? "active" : ""}`;
 268 |       span.textContent = `${tag} (${count})`;
 269 |       span.title = `Filter by ${tag}`;
 270 |       span.addEventListener("click", () => {
 271 |         activeTag = active === tag ? null : tag;
 272 |         renderAll();
 273 |       });
 274 |       tagCloud.appendChild(span);
 275 |     });
 276 | }
 277 | 
 278 | function renderGrid(list) {
 279 |   grid.innerHTML = "";
 280 |   if (list.length === 0) {
 281 |     const empty = document.createElement("div");
 282 |     empty.style.opacity = ".7";
 283 |     empty.textContent = "No items yet. Save by clicking ‚ÄúÔºã Save‚Äù on a linked image.";
 284 |     grid.appendChild(empty);
 285 |     return;
 286 |   }
 287 | 
 288 |   list.forEach(item => {
 289 |     const node = cardTpl.content.firstElementChild.cloneNode(true);
 290 | 
 291 |     const aThumb = node.querySelector(".thumb");
 292 |     const img = node.querySelector("img");
 293 |     const titleDiv = node.querySelector(".title");
 294 |     const linkA = node.querySelector(".link");
 295 | 
 296 |     if (batchMode) {
 297 |       const cb = document.createElement("input");
 298 |       cb.type = "checkbox";
 299 |       cb.className = "select-card";
 300 |       cb.dataset.id = item.id;
 301 |       cb.style.margin = "6px";
 302 |       node.prepend(cb);
 303 |     }
 304 | 
 305 |     aThumb.href = item.url;
 306 |     img.src = item.img;
 307 |     img.alt = item.title || "";
 308 |     titleDiv.textContent = item.title || "";
 309 | 
 310 |     linkA.href = item.url;
 311 |     linkA.textContent = truncate(item.url, 48);
 312 |     linkA.title = item.url;
 313 | 
 314 |     grid.appendChild(node);
 315 |   });
 316 | }
 317 | 
 318 | function truncate(str, n) {
 319 |   return str.length > n ? str.slice(0, n - 1) + "‚Ä¶" : str;
 320 | }
 321 | 
 322 | function parseTags(str) {
 323 |   return str
 324 |     .split(",")
 325 |     .map(s => s.trim())
 326 |     .filter(Boolean)
 327 |     .slice(0, 20);
 328 | }
 329 | 
 330 | function getCheckedIds() {
 331 |   return Array.from(document.querySelectorAll(".select-card:checked")).map(cb => cb.dataset.id);
 332 | }
 333 | 
 334 | function makeId() {
 335 |   return `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
 336 | }
 337 | 
 338 | function resetManualForm() {
 339 |   manualUrl.value = "";
 340 |   manualImg.value = "";
 341 |   manualTitle.value = "";
 342 |   manualTags.value = "";
 343 | }
 344 | 
 345 | function closeManualPanel() {
 346 |   resetManualForm();
 347 |   manualPanel.hidden = true;
 348 |   manualPanelOpen = false;
 349 |   addManualBtn.textContent = "Add Entry";
 350 | }
 351 | 
 352 | function resetGlobalForm() {
 353 |   globalTitle.value = "";
 354 |   globalImg.value = "";
 355 |   globalTags.value = "";
 356 | }
 357 | 
 358 | function closeEditPanel() {
 359 |   resetGlobalForm();
 360 |   editPanelOpen = false;
 361 |   batchMode = null;
 362 |   globalEditPanel.hidden = true;
 363 |   editModeBtn.textContent = "Edit";
 364 | }
]]></file>
    <file path="generate_codebase_xml.py" lang="python"><![CDATA[
   1 | #!/usr/bin/env python3
   2 | import os
   3 | import datetime
   4 | from pathlib import Path
   5 | from xml.sax.saxutils import escape
   6 | 
   7 | # Optional dependency: install with `pip install pathspec`
   8 | try:
   9 |     import pathspec
  10 | except ImportError:
  11 |     pathspec = None
  12 |     print("‚ö†Ô∏è  pathspec not installed; .gitignore will be ignored. Run: pip install pathspec")
  13 | 
  14 | # ---------- CONFIG ----------
  15 | REPO_DIR = Path.cwd()  # run from the directory you want to export
  16 | OUTPUT_FILE = REPO_DIR / "codebase.xml"
  17 | VALID_EXTENSIONS = (
  18 |     ".js", ".jsx", ".ts", ".tsx", ".py", ".html", ".css",
  19 |     ".json", ".yml", ".yaml", ".sh", ".md"
  20 | )
  21 | IGNORE_DIRS = {
  22 |     "node_modules", "dist", "build", ".git", ".cache", ".vite",
  23 |     ".idea", "__pycache__", ".DS_Store"
  24 | }
  25 | SKIP_FILES = {
  26 |     "package-lock.json", "pnpm-lock.yaml", "yarn.lock"
  27 | }
  28 | # ----------------------------
  29 | 
  30 | 
  31 | def detect_lang(ext: str) -> str:
  32 |     # lightweight mapping inline; avoids separate dict
  33 |     match ext.lower():
  34 |         case ".py": return "python"
  35 |         case ".js": return "javascript"
  36 |         case ".jsx": return "javascriptreact"
  37 |         case ".ts": return "typescript"
  38 |         case ".tsx": return "typescriptreact"
  39 |         case ".html": return "html"
  40 |         case ".css": return "css"
  41 |         case ".json": return "json"
  42 |         case ".yml" | ".yaml": return "yaml"
  43 |         case ".sh": return "bash"
  44 |         case ".md": return "markdown"
  45 |         case _: return "text"
  46 | 
  47 | 
  48 | def load_gitignore(repo_dir: Path):
  49 |     gitignore_path = repo_dir / ".gitignore"
  50 |     if gitignore_path.exists() and pathspec:
  51 |         spec = pathspec.PathSpec.from_lines("gitwildmatch", gitignore_path.read_text().splitlines())
  52 |         return spec
  53 |     return None
  54 | 
  55 | 
  56 | def is_ignored(path: Path, repo_dir: Path, spec):
  57 |     if not spec:
  58 |         return False
  59 |     rel = str(path.relative_to(repo_dir))
  60 |     return spec.match_file(rel)
  61 | 
  62 | 
  63 | def number_lines(filepath: Path):
  64 |     with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
  65 |         return [f"{str(i+1).rjust(4)} | {line.rstrip()}" for i, line in enumerate(f)]
  66 | 
  67 | 
  68 | def should_skip_dir(path: Path):
  69 |     name = path.name
  70 |     if name.startswith(".") and name not in {".github"}:
  71 |         return True
  72 |     return name in IGNORE_DIRS
  73 | 
  74 | 
  75 | def build_tree_xml(repo_dir: Path, spec, indent=2):
  76 |     xml_lines = []
  77 |     seen_dirs = set()
  78 | 
  79 |     for root, dirs, files in os.walk(repo_dir):
  80 |         # prune ignored/system dirs
  81 |         dirs[:] = [d for d in dirs if not should_skip_dir(Path(root) / d)]
  82 |         rel_root = Path(root).relative_to(repo_dir)
  83 | 
  84 |         # skip duplicate folder entries
  85 |         if rel_root not in seen_dirs and rel_root != Path("."):
  86 |             depth = len(rel_root.parts)
  87 |             xml_lines.append(" " * (indent * depth) + f'<folder name="{escape(rel_root.name)}">')
  88 |             seen_dirs.add(rel_root)
  89 | 
  90 |         # add visible subfolders and files
  91 |         for d in sorted(dirs):
  92 |             sub_path = Path(root) / d
  93 |             if not is_ignored(sub_path, repo_dir, spec):
  94 |                 depth = len(Path(root, d).relative_to(repo_dir).parts)
  95 |                 xml_lines.append(" " * (indent * depth) + f'<folder name="{escape(d)}" />')
  96 | 
  97 |         for f in sorted(files):
  98 |             file_path = Path(root) / f
  99 |             if is_ignored(file_path, repo_dir, spec):
 100 |                 continue
 101 |             if f in SKIP_FILES or file_path.suffix not in VALID_EXTENSIONS:
 102 |                 continue
 103 |             rel = file_path.relative_to(repo_dir)
 104 |             lang = detect_lang(file_path.suffix)
 105 |             depth = len(rel.parts)
 106 |             xml_lines.append(
 107 |                 " " * (indent * depth)
 108 |                 + f'<file name="{escape(f)}" path="{escape(str(rel))}" lang="{lang}" />'
 109 |             )
 110 | 
 111 |     # close all opened folders (flattened style)
 112 |     for rel in sorted(seen_dirs, key=lambda p: len(p.parts), reverse=True):
 113 |         xml_lines.append(" " * (indent * len(rel.parts)) + "</folder>")
 114 | 
 115 |     return "\n".join(xml_lines)
 116 | 
 117 | 
 118 | def build_files_xml(repo_dir: Path, spec):
 119 |     xml_lines = []
 120 |     for root, dirs, files in os.walk(repo_dir):
 121 |         dirs[:] = [d for d in dirs if not should_skip_dir(Path(root) / d)]
 122 |         for f in sorted(files):
 123 |             file_path = Path(root) / f
 124 |             if is_ignored(file_path, repo_dir, spec):
 125 |                 continue
 126 |             if f in SKIP_FILES or file_path.suffix not in VALID_EXTENSIONS:
 127 |                 continue
 128 |             # auto-skip large JSON data blobs
 129 |             if file_path.suffix == ".json" and file_path.stat().st_size > 10_000:
 130 |                 continue
 131 | 
 132 |             relpath = file_path.relative_to(repo_dir)
 133 |             lang = detect_lang(file_path.suffix)
 134 |             numbered = "\n".join(number_lines(file_path))
 135 |             xml_lines.append(
 136 |                 f'    <file path="{escape(str(relpath))}" lang="{lang}"><![CDATA[\n{numbered}\n]]></file>'
 137 |             )
 138 |     return "\n".join(xml_lines)
 139 | 
 140 | 
 141 | def main():
 142 |     spec = load_gitignore(REPO_DIR)
 143 | 
 144 |     xml = []
 145 |     xml.append('<?xml version="1.0" encoding="UTF-8"?>')
 146 |     xml.append("<codebase>")
 147 |     xml.append("  <info>")
 148 |     xml.append("    <description>")
 149 |     xml.append("      Each file includes prefixed line numbers for reference.")
 150 |     xml.append("      These numbers are metadata for navigation only ‚Äî use them when identifying code regions,")
 151 |     xml.append("      Do not include them in any source or patch code being provided to the user.")
 152 |     xml.append("      Do reference the line numbers in coversation when it will help navigate the user to the code you want to draw their attention towards.")
 153 |     xml.append("    </description>")
 154 |     xml.append(f"    <generated>{datetime.datetime.utcnow().isoformat()}Z</generated>")
 155 |     xml.append(f"    <root>{escape(str(REPO_DIR))}</root>")
 156 |     xml.append("  </info>\n")
 157 | 
 158 |     xml.append("  <tree>")
 159 |     xml.append(build_tree_xml(REPO_DIR, spec))
 160 |     xml.append("  </tree>\n")
 161 | 
 162 |     xml.append("  <files>")
 163 |     xml.append(build_files_xml(REPO_DIR, spec))
 164 |     xml.append("  </files>\n")
 165 | 
 166 |     xml.append("</codebase>")
 167 | 
 168 |     OUTPUT_FILE.write_text("\n".join(xml), encoding="utf-8")
 169 |     print(f"‚úÖ Generated {OUTPUT_FILE}")
 170 | 
 171 | 
 172 | if __name__ == "__main__":
 173 |     main()
 174 | 
]]></file>
    <file path="index_repo.py" lang="python"><![CDATA[
   1 | #!/usr/bin/env python3
   2 | """
   3 | Repo Indexer for AI Code Review
   4 | ===============================
   5 | This script indexes a local Git repository into a text file for AI analysis.
   6 | It lists all tracked files, reads their contents, and concatenates them with metadata.
   7 | 
   8 | Usage:
   9 |     python index_repo.py [output_file]
  10 |     If no output_file is provided, defaults to 'repo_index.txt'.
  11 | 
  12 | Requirements:
  13 |     - Python 3.x
  14 |     - Run from the root of a Git repository.
  15 | """
  16 | 
  17 | import subprocess
  18 | import sys
  19 | import os
  20 | from pathlib import Path
  21 | import argparse
  22 | 
  23 | def run_git_command(cmd):
  24 |     """Run a Git command and return stdout as a list of lines."""
  25 |     try:
  26 |         result = subprocess.run(cmd, shell=True, capture_output=True, text=True, check=True)
  27 |         return result.stdout.strip().split('\n')
  28 |     except subprocess.CalledProcessError as e:
  29 |         print(f"Error running Git command '{cmd}': {e}")
  30 |         sys.exit(1)
  31 | 
  32 | def is_text_file(file_path):
  33 |     """Check if a file is text-based (not binary)."""
  34 |     try:
  35 |         with open(file_path, 'rb') as f:
  36 |             sample = f.read(1024)
  37 |             return b'\0' not in sample  # Null bytes indicate binary
  38 |     except:
  39 |         return False
  40 | 
  41 | def should_include_file(file_path):
  42 |     """Filter files: include common code/docs, exclude binaries/large files."""
  43 |     path = Path(file_path)
  44 |     if path.is_dir():
  45 |         return False
  46 |     # Skip common ignores (even if not in .gitignore)
  47 |     if any(skip in file_path for skip in ['.git/', '__pycache__', '*.pyc', '*.pyo', '*.pyd']):
  48 |         return False
  49 |     # Include common code and doc files
  50 |     if path.suffix in {'.py', '.js', '.ts', '.java', '.cpp', '.c', '.h', '.md', '.txt', '.json', '.yaml', '.yml', '.html', '.css', '.sh', '.sql'}:
  51 |         return True
  52 |     # For other files, check if text and <1MB
  53 |     if is_text_file(file_path):
  54 |         stat = path.stat()
  55 |         return stat.st_size < 1_000_000  # 1MB limit
  56 |     return False
  57 | 
  58 | def read_file_content(file_path):
  59 |     """Read file content, handling encoding errors gracefully."""
  60 |     try:
  61 |         with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
  62 |             return f.read()
  63 |     except Exception as e:
  64 |         print(f"Warning: Could not read {file_path}: {e}")
  65 |         return f"# [ERROR: Could not read file]"
  66 | 
  67 | def index_repo(output_file):
  68 |     """Main indexing function."""
  69 |     # Get list of tracked files
  70 |     files = run_git_command('git ls-files')
  71 | 
  72 |     # Helper to run git log for date (handles quoting safely)
  73 |     def get_commit_date(file_path=''):
  74 |         cmd = f'git log -1 --format="%cI" -- {file_path}' if file_path else 'git log -1 --format="%cI"'
  75 |         return os.popen(cmd).read().strip() or 'Unknown'
  76 | 
  77 |     with open(output_file, 'w', encoding='utf-8') as out:
  78 |         out.write("# Git Repository Index for AI Review\n")
  79 |         out.write(f"# Generated on: {get_commit_date()}\n")
  80 |         out.write(f"# Repo: {os.getcwd()}\n")
  81 |         out.write(f"# Total files indexed: {len(files)}\n\n")
  82 | 
  83 |         for file_path in files:
  84 |             if not should_include_file(file_path):
  85 |                 continue
  86 | 
  87 |             content = read_file_content(file_path)
  88 |             out.write(f"## FILE: {file_path}\n")
  89 |             out.write("### Metadata\n")
  90 |             out.write(f"- Size: {Path(file_path).stat().st_size} bytes\n")
  91 |             out.write(f"- Last commit: {get_commit_date(file_path)}\n\n")
  92 |             out.write("### Content\n")
  93 |             out.write(content)
  94 |             out.write("\n" + "="*80 + "\n\n")  # Separator for easy chunking
  95 | 
  96 |     print(f"Indexing complete! Output saved to '{output_file}'.")
  97 |     print(f"Indexed {len([f for f in files if should_include_file(f)])} files.")
  98 | 
  99 | if __name__ == "__main__":
 100 |     parser = argparse.ArgumentParser(description="Index a local Git repo for AI code review.")
 101 |     parser.add_argument("output", nargs="?", default="repo_index.txt", help="Output file path (default: repo_index.txt)")
 102 |     args = parser.parse_args()
 103 | 
 104 |     # Check if in a Git repo
 105 |     if not os.popen('git rev-parse --git-dir').read().strip():
 106 |         print("Error: Not in a Git repository. Run from the repo root.")
 107 |         sys.exit(1)
 108 | 
 109 |     index_repo(args.output)
]]></file>
    <file path="manifest-chromium.json" lang="json"><![CDATA[
   1 | {
   2 |   "manifest_version": 3,
   3 |   "name": "VidTab Gallery",
   4 |   "version": "1.1.0",
   5 |   "description": "Save linked images as visual video bookmarks and view them in a full gallery tab. Now with manual add/edit and bookmarks.",
   6 |   "permissions": ["storage", "tabs", "contextMenus"],
   7 |   "host_permissions": ["<all_urls>"],
   8 |   "action": {
   9 |     "default_title": "Open VidTab Gallery"
  10 |   },
  11 |   "background": {
  12 |     "service_worker": "background.js"
  13 |   },
  14 |   "content_scripts": [
  15 |     {
  16 |       "matches": ["<all_urls>"],
  17 |       "css": ["contentStyles.css"],
  18 |       "js": ["contentScript.js"],
  19 |       "run_at": "document_idle"
  20 |     }
  21 |   ],
  22 |   "web_accessible_resources": [
  23 |     {
  24 |       "resources": ["gallery.html", "gallery.js", "gallery.css"],
  25 |       "matches": ["<all_urls>"]
  26 |     }
  27 |   ],
  28 |   "icons": {
  29 |     "16": "icons/16.png",
  30 |     "32": "icons/32.png",
  31 |     "128": "icons/128.png"
  32 |   }
  33 | }
]]></file>
    <file path="manifest-firefox.json" lang="json"><![CDATA[
   1 | {
   2 |   "manifest_version": 3,
   3 |   "name": "VidTab Gallery",
   4 |   "version": "1.1.0",
   5 |   "description": "Save linked images as visual video bookmarks and view them in a full gallery tab. Now with manual add/edit and bookmarks.",
   6 |   "permissions": ["storage", "tabs", "contextMenus"],
   7 |   "host_permissions": ["<all_urls>"],
   8 |   "action": {
   9 |     "default_title": "Open VidTab Gallery"
  10 |   },
  11 |   "background": {
  12 |     // Chrome uses service workers for background tasks under MV3.  Firefox does not yet support
  13 |     // service workers, so we specify both the service worker and a fallback background script.
  14 |     "service_worker": "background.js",
  15 |     "scripts": ["background.js"]
  16 |   },
  17 |   "content_scripts": [
  18 |     {
  19 |       "matches": ["<all_urls>"],
  20 |       "css": ["contentStyles.css"],
  21 |       "js": ["contentScript.js"],
  22 |       "run_at": "document_idle"
  23 |     }
  24 |   ],
  25 |   "web_accessible_resources": [
  26 |     {
  27 |       "resources": ["gallery.html", "gallery.js", "gallery.css"],
  28 |       // Provide a match pattern for Firefox; Chrome allows omission of matches
  29 |       "matches": ["<all_urls>"]
  30 |     }
  31 |   ],
  32 |   "icons": {
  33 |     "16": "icons/16.png",
  34 |     "32": "icons/32.png",
  35 |     "128": "icons/128.png"
  36 |   },
  37 |   "browser_specific_settings": {
  38 |     "gecko": {
  39 |       // Use a pseudo‚ÄëGUID as an add‚Äëon identifier.  It looks like an e‚Äëmail address but does not
  40 |       // correspond to any real account.  Using the same ID across your devices allows sync.
  41 |       "id": "vizion@dragonsupremeai",
  42 |       // Require Firefox 121 or later, which supports MV3 with both service workers and background scripts
  43 |       "strict_min_version": "121.0",
  44 |       // Indicate that this extension does not collect or transmit any user data off the device.  As
  45 |       // of late 2025 this field is mandatory for new add‚Äëon submissions.
  46 |       "data_collection_permissions": {
  47 |         "required": "none"
  48 |       }
  49 |     }
  50 |   }
  51 | }
]]></file>
    <file path="package.json" lang="json"><![CDATA[
   1 | {
   2 |   "name": "mediamarks-server",
   3 |   "version": "0.1.0",
   4 |   "description": "Backend service for MediaMarks to persist bookmarks in MySQL.",
   5 |   "main": "server.js",
   6 |   "scripts": {
   7 |     "start": "node server.js"
   8 |   },
   9 |   "dependencies": {
  10 |     "express": "^4.18.2",
  11 |     "mysql2": "^3.6.0",
  12 |     "dotenv": "^16.0.3"
  13 |   }
  14 | }
]]></file>
    <file path="popup.html" lang="html"><![CDATA[
   1 | <!doctype html>
   2 | <html>
   3 | <head>
   4 |   <meta charset="utf-8" />
   5 |   <title>VidTab</title>
   6 |   <style>
   7 |     body { margin: 0; padding: 10px; font: 14px system-ui; width: 220px; }
   8 |     button { width: 100%; padding: 8px; }
   9 |     small { display: block; opacity: .7; margin-top: 8px; }
  10 |   </style>
  11 | </head>
  12 | <body>
  13 |   <button id="open">Open Gallery</button>
  14 |   <small>Tip: hover a linked image on any website and click ‚ÄúÔºã Save‚Äù.</small>
  15 |   <script src="popup.js"></script>
  16 | </body>
  17 | </html>
]]></file>
    <file path="popup.js" lang="javascript"><![CDATA[
   1 | document.getElementById("open").addEventListener("click", async () => {
   2 |   await chrome.runtime.sendMessage({ type: "OPEN_GALLERY" });
   3 |   window.close();
   4 | });
]]></file>
    <file path="server.js" lang="javascript"><![CDATA[
   1 | #!/usr/bin/env node
   2 | /*
   3 |  * Simple Express server providing a REST API for MediaMarks bookmarks.
   4 |  *
   5 |  * The service uses a MySQL database to persist bookmarks and exposes
   6 |  * endpoints for clients to create, read, update and delete items.  It
   7 |  * also supports importing/exporting a full set of bookmarks for backup
   8 |  * and synchronisation across devices.
   9 |  *
  10 |  * Configuration:  Database connection details are read from environment
  11 |  * variables: DB_HOST, DB_USER, DB_PASSWORD, DB_NAME.  You can create
  12 |  * these variables in a .env file during development or set them in
  13 |  * your deployment environment.
  14 |  */
  15 | 
  16 | const express = require('express');
  17 | const mysql = require('mysql2/promise');
  18 | const dotenv = require('dotenv');
  19 | 
  20 | // Load environment variables from a .env file if present
  21 | dotenv.config();
  22 | 
  23 | const app = express();
  24 | app.use(express.json());
  25 | 
  26 | // Create a MySQL connection pool.  Using a pool allows the server to
  27 | // handle concurrent requests efficiently by reusing database connections.
  28 | const pool = mysql.createPool({
  29 |   host: process.env.DB_HOST || 'localhost',
  30 |   user: process.env.DB_USER || 'mediamarks_user',
  31 |   password: process.env.DB_PASSWORD || 'mediamarks_pass',
  32 |   database: process.env.DB_NAME || 'mediamarks',
  33 |   waitForConnections: true,
  34 |   connectionLimit: 10,
  35 |   queueLimit: 0
  36 | });
  37 | 
  38 | // Initialise database schema if necessary.  This function runs when the
  39 | // server starts and ensures the bookmarks table exists.  If the table
  40 | // already exists, the CREATE TABLE IF NOT EXISTS statement will have
  41 | // no effect.
  42 | async function initDb() {
  43 |   const createSql = `
  44 |     CREATE TABLE IF NOT EXISTS bookmarks (
  45 |       id VARCHAR(255) PRIMARY KEY,
  46 |       user_id VARCHAR(255) NOT NULL,
  47 |       url TEXT NOT NULL,
  48 |       img TEXT NOT NULL,
  49 |       title TEXT,
  50 |       tags TEXT,
  51 |       source_page_url TEXT,
  52 |       created_at BIGINT NOT NULL,
  53 |       updated_at BIGINT
  54 |     );
  55 |   `;
  56 |   const conn = await pool.getConnection();
  57 |   try {
  58 |     await conn.query(createSql);
  59 |   } finally {
  60 |     conn.release();
  61 |   }
  62 | }
  63 | 
  64 | // Helper to convert comma separated tags into a canonical string
  65 | function normaliseTags(tags) {
  66 |   if (!Array.isArray(tags)) return tags ? String(tags) : '';
  67 |   return tags
  68 |     .map(t => t.trim())
  69 |     .filter(Boolean)
  70 |     .join(',');
  71 | }
  72 | 
  73 | // GET /bookmarks?user_id=...  ‚Äì fetch all bookmarks for a given user.
  74 | app.get('/bookmarks', async (req, res) => {
  75 |   const userId = req.query.user_id;
  76 |   if (!userId) {
  77 |     return res.status(400).json({ error: 'user_id query parameter is required' });
  78 |   }
  79 |   const conn = await pool.getConnection();
  80 |   try {
  81 |     const [rows] = await conn.query('SELECT * FROM bookmarks WHERE user_id = ?', [userId]);
  82 |     // Convert comma separated tag string back into arrays on the fly
  83 |     const items = rows.map(row => ({
  84 |       id: row.id,
  85 |       user_id: row.user_id,
  86 |       url: row.url,
  87 |       img: row.img,
  88 |       title: row.title,
  89 |       tags: row.tags ? row.tags.split(',').filter(Boolean) : [],
  90 |       sourcePageUrl: row.source_page_url,
  91 |       createdAt: row.created_at,
  92 |       updatedAt: row.updated_at
  93 |     }));
  94 |     res.json({ items });
  95 |   } catch (err) {
  96 |     console.error(err);
  97 |     res.status(500).json({ error: 'Database error fetching bookmarks' });
  98 |   } finally {
  99 |     conn.release();
 100 |   }
 101 | });
 102 | 
 103 | // POST /bookmarks  ‚Äì create a new bookmark.
 104 | app.post('/bookmarks', async (req, res) => {
 105 |   const item = req.body;
 106 |   if (!item || !item.user_id || !item.id) {
 107 |     return res.status(400).json({ error: 'user_id and id are required in request body' });
 108 |   }
 109 |   const conn = await pool.getConnection();
 110 |   try {
 111 |     const tags = normaliseTags(item.tags);
 112 |     const sql = `INSERT INTO bookmarks (id, user_id, url, img, title, tags, source_page_url, created_at, updated_at)
 113 |       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
 114 |       ON DUPLICATE KEY UPDATE url = VALUES(url), img = VALUES(img), title = VALUES(title), tags = VALUES(tags), source_page_url = VALUES(source_page_url), updated_at = VALUES(updated_at)`;
 115 |     await conn.execute(sql, [
 116 |       item.id,
 117 |       item.user_id,
 118 |       item.url,
 119 |       item.img,
 120 |       item.title || null,
 121 |       tags || null,
 122 |       item.sourcePageUrl || null,
 123 |       item.createdAt || Date.now(),
 124 |       Date.now()
 125 |     ]);
 126 |     res.json({ success: true });
 127 |   } catch (err) {
 128 |     console.error(err);
 129 |     res.status(500).json({ error: 'Database error creating bookmark' });
 130 |   } finally {
 131 |     conn.release();
 132 |   }
 133 | });
 134 | 
 135 | // PUT /bookmarks/:id  ‚Äì update an existing bookmark.  The request body may
 136 | // contain only the fields to be updated.  The user_id query parameter
 137 | // ensures the user owns the item.
 138 | app.put('/bookmarks/:id', async (req, res) => {
 139 |   const id = req.params.id;
 140 |   const userId = req.query.user_id;
 141 |   if (!userId) {
 142 |     return res.status(400).json({ error: 'user_id query parameter is required' });
 143 |   }
 144 |   const fields = req.body || {};
 145 |   const conn = await pool.getConnection();
 146 |   try {
 147 |     // Build dynamic SET clause
 148 |     const updates = [];
 149 |     const values = [];
 150 |     if (fields.url) {
 151 |       updates.push('url = ?');
 152 |       values.push(fields.url);
 153 |     }
 154 |     if (fields.img) {
 155 |       updates.push('img = ?');
 156 |       values.push(fields.img);
 157 |     }
 158 |     if (fields.title) {
 159 |       updates.push('title = ?');
 160 |       values.push(fields.title);
 161 |     }
 162 |     if (fields.tags) {
 163 |       updates.push('tags = ?');
 164 |       values.push(normaliseTags(fields.tags));
 165 |     }
 166 |     if (fields.sourcePageUrl) {
 167 |       updates.push('source_page_url = ?');
 168 |       values.push(fields.sourcePageUrl);
 169 |     }
 170 |     // Always update updated_at
 171 |     updates.push('updated_at = ?');
 172 |     values.push(Date.now());
 173 |     if (!updates.length) {
 174 |       return res.status(400).json({ error: 'No fields provided for update' });
 175 |     }
 176 |     values.push(id, userId);
 177 |     const sql = `UPDATE bookmarks SET ${updates.join(', ')} WHERE id = ? AND user_id = ?`;
 178 |     const [result] = await conn.execute(sql, values);
 179 |     if (result.affectedRows === 0) {
 180 |       return res.status(404).json({ error: 'Bookmark not found' });
 181 |     }
 182 |     res.json({ success: true });
 183 |   } catch (err) {
 184 |     console.error(err);
 185 |     res.status(500).json({ error: 'Database error updating bookmark' });
 186 |   } finally {
 187 |     conn.release();
 188 |   }
 189 | });
 190 | 
 191 | // DELETE /bookmarks/:id?user_id=...  ‚Äì delete a bookmark.  The user_id ensures
 192 | // that only the owner can delete the item.
 193 | app.delete('/bookmarks/:id', async (req, res) => {
 194 |   const id = req.params.id;
 195 |   const userId = req.query.user_id;
 196 |   if (!userId) {
 197 |     return res.status(400).json({ error: 'user_id query parameter is required' });
 198 |   }
 199 |   const conn = await pool.getConnection();
 200 |   try {
 201 |     const [result] = await conn.execute('DELETE FROM bookmarks WHERE id = ? AND user_id = ?', [id, userId]);
 202 |     if (result.affectedRows === 0) {
 203 |       return res.status(404).json({ error: 'Bookmark not found' });
 204 |     }
 205 |     res.json({ success: true });
 206 |   } catch (err) {
 207 |     console.error(err);
 208 |     res.status(500).json({ error: 'Database error deleting bookmark' });
 209 |   } finally {
 210 |     conn.release();
 211 |   }
 212 | });
 213 | 
 214 | // GET /bookmarks/export?user_id=...  ‚Äì export all bookmarks as JSON.  This
 215 | // endpoint simply wraps the GET /bookmarks route for convenience.
 216 | app.get('/bookmarks/export', async (req, res) => {
 217 |   const userId = req.query.user_id;
 218 |   if (!userId) {
 219 |     return res.status(400).json({ error: 'user_id query parameter is required' });
 220 |   }
 221 |   const conn = await pool.getConnection();
 222 |   try {
 223 |     const [rows] = await conn.query('SELECT * FROM bookmarks WHERE user_id = ?', [userId]);
 224 |     res.setHeader('Content-Type', 'application/json');
 225 |     res.setHeader('Content-Disposition', `attachment; filename="bookmarks-${userId}.json"`);
 226 |     res.end(JSON.stringify(rows, null, 2));
 227 |   } catch (err) {
 228 |     console.error(err);
 229 |     res.status(500).json({ error: 'Database error exporting bookmarks' });
 230 |   } finally {
 231 |     conn.release();
 232 |   }
 233 | });
 234 | 
 235 | // POST /bookmarks/import  ‚Äì import bookmarks from a JSON array.  The request
 236 | // body should contain { user_id: string, items: Array }.  Each item is
 237 | // inserted or updated in the database.
 238 | app.post('/bookmarks/import', async (req, res) => {
 239 |   const { user_id: userId, items } = req.body;
 240 |   if (!userId || !Array.isArray(items)) {
 241 |     return res.status(400).json({ error: 'user_id and items array are required' });
 242 |   }
 243 |   const conn = await pool.getConnection();
 244 |   try {
 245 |     const sql = `INSERT INTO bookmarks (id, user_id, url, img, title, tags, source_page_url, created_at, updated_at)
 246 |       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
 247 |       ON DUPLICATE KEY UPDATE url = VALUES(url), img = VALUES(img), title = VALUES(title), tags = VALUES(tags), source_page_url = VALUES(source_page_url), updated_at = VALUES(updated_at)`;
 248 |     const tasks = items.map(item => conn.execute(sql, [
 249 |       item.id,
 250 |       userId,
 251 |       item.url,
 252 |       item.img,
 253 |       item.title || null,
 254 |       normaliseTags(item.tags) || null,
 255 |       item.sourcePageUrl || null,
 256 |       item.createdAt || Date.now(),
 257 |       Date.now()
 258 |     ]));
 259 |     await Promise.all(tasks);
 260 |     res.json({ success: true, imported: items.length });
 261 |   } catch (err) {
 262 |     console.error(err);
 263 |     res.status(500).json({ error: 'Database error importing bookmarks' });
 264 |   } finally {
 265 |     conn.release();
 266 |   }
 267 | });
 268 | 
 269 | // Start the server after ensuring the database schema exists.
 270 | const port = process.env.PORT || 3000;
 271 | initDb().then(() => {
 272 |   app.listen(port, () => {
 273 |     console.log(`MediaMarks backend listening on port ${port}`);
 274 |   });
 275 | }).catch(err => {
 276 |   console.error('Failed to initialise database:', err);
 277 |   process.exit(1);
 278 | });
]]></file>
    <file path="setup-mediamarks-server.sh" lang="bash"><![CDATA[
   1 | cat <<'EOF' > setup-mediamarks-server.sh && chmod +x setup-mediamarks-server.sh && ./setup-mediamarks-server.sh
   2 | #!/bin/bash
   3 | 
   4 | # This script installs Node.js and MySQL on Ubuntu-based systems, creates
   5 | # a MySQL database and user for MediaMarks, installs the backend
   6 | # dependencies, initialises the schema and starts the server.  Run this
   7 | # script from the root of the repository (the directory containing the
   8 | # `server` folder).  Adjust credentials or port as needed.
   9 | 
  10 | set -e
  11 | 
  12 | echo "üîß Installing Node.js, npm and MySQL server..."
  13 | sudo apt update && sudo apt install -y nodejs npm mysql-server
  14 | 
  15 | echo "üöÄ Starting MySQL service..."
  16 | sudo service mysql start
  17 | 
  18 | DB_NAME="mediamarks"
  19 | DB_USER="vizion"
  20 | DB_PASS="firebird"
  21 | 
  22 | echo "üîß Creating MySQL database and user (if they don't already exist)..."
  23 | sudo mysql -e "CREATE DATABASE IF NOT EXISTS $DB_NAME; \n\
  24 | CREATE USER IF NOT EXISTS '$DB_USER'@'localhost' IDENTIFIED BY '$DB_PASS'; \n\
  25 | GRANT ALL PRIVILEGES ON $DB_NAME.* TO '$DB_USER'@'localhost'; \n\
  26 | FLUSH PRIVILEGES;"
  27 | 
  28 | echo "üîß Installing backend dependencies in ./server..."
  29 | pushd server >/dev/null
  30 | npm install
  31 | 
  32 | echo "üîß Importing database schema..."
  33 | mysql -u "$DB_USER" -p"$DB_PASS" "$DB_NAME" < db.sql
  34 | 
  35 | echo "üöÄ Starting MediaMarks backend server on port 3000..."
  36 | npm start &
  37 | popd >/dev/null
  38 | 
  39 | echo "‚úÖ Backend setup complete.  The server is running in the background."
  40 | EOF
]]></file>
    <file path="patches/ai-changes.json" lang="json"><![CDATA[
   1 | [
   2 |   {
   3 |     "file": "background.js",
   4 |     "action": "insert_after",
   5 |     "anchor": "const GALLERY_PATH = \"gallery.html\";",
   6 |     "content": "const API_BASE = 'http://localhost:3000';\nconst USER_ID = 'default-user';\n",
   7 |     "description": "Define backend API URL and a default user ID for syncing.",
   8 |     "feature": "sync"
   9 |   },
  10 |   {
  11 |     "file": "background.js",
  12 |     "action": "insert_after",
  13 |     "anchor": "await chrome.storage.local.set({ items });",
  14 |     "content": "  // Persist the item remotely for cross‚Äëdevice synchronisation.\n  sendItemToServer(item).catch(err => console.error(err));",
  15 |     "description": "Send newly saved bookmark to the backend API.",
  16 |     "feature": "sync"
  17 |   },
  18 |   {
  19 |     "file": "background.js",
  20 |     "action": "append",
  21 |     "content": "\n/**\n * Send a bookmark to the backend API. The server will upsert the record based on the item id and user_id.\n * Any network errors are logged but do not prevent local storage from being updated.\n */\nasync function sendItemToServer(item) {\n  const payload = { ...item, user_id: USER_ID };\n  try {\n    await fetch(`${API_BASE}/bookmarks`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(payload)\n    });\n  } catch (err) {\n    console.error('Failed to sync item to server', err);\n  }\n}\n\n/**\n * Fetch all bookmarks for this user from the backend and merge them into local storage.\n * New items from the server are appended to the local collection. Existing items are left untouched.\n */\nasync function syncFromServer() {\n  try {\n    const res = await fetch(`${API_BASE}/bookmarks?user_id=${encodeURIComponent(USER_ID)}`);\n    const data = await res.json();\n    const remoteItems = data.items || [];\n    const localData = await chrome.storage.local.get({ items: [] });\n    const localItems = localData.items;\n    let changed = false;\n    remoteItems.forEach(remote => {\n      if (!localItems.some(local => local.id === remote.id)) {\n        localItems.push(remote);\n        changed = true;\n      }\n    });\n    if (changed) {\n      await chrome.storage.local.set({ items: localItems });\n    }\n  } catch (err) {\n    console.error('Failed to sync bookmarks from server', err);\n  }\n}\n\n// Kick off a sync when the extension is installed or the browser starts.\nchrome.runtime.onInstalled.addListener(() => {\n  syncFromServer();\n});\n\nchrome.runtime.onStartup.addListener(() => {\n  syncFromServer();\n});\n",
  22 |     "description": "Define helper functions to sync bookmarks with the backend and start syncing on install/startup.",
  23 |     "feature": "sync"
  24 |   },
  25 |   {
  26 |     "file": "gallery.js",
  27 |     "action": "insert_after",
  28 |     "anchor": "chrome.storage.onChanged.addListener((changes, area)",
  29 |     "content": "\n  // Initialise import/export buttons if they exist in the gallery HTML.\n  const exportBtn = document.getElementById('export-btn');\n  const importInput = document.getElementById('import-btn');\n  if (exportBtn) {\n    exportBtn.addEventListener('click', async () => {\n      const data = await chrome.storage.local.get({ items: [] });\n      const blob = new Blob([JSON.stringify(data.items, null, 2)], { type: 'application/json' });\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = 'mediamarks-backup.json';\n      a.style.display = 'none';\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    });\n  }\n  if (importInput) {\n    importInput.addEventListener('change', async (event) => {\n      const file = event.target.files[0];\n      if (!file) return;\n      const text = await file.text();\n      try {\n        const imported = JSON.parse(text);\n        if (!Array.isArray(imported)) {\n          alert('Imported file does not contain an array of bookmarks.');\n          return;\n        }\n        const data = await chrome.storage.local.get({ items: [] });\n        const localItems = data.items;\n        let changed = false;\n        imported.forEach(item => {\n          if (!localItems.some(x => x.id === item.id)) {\n            localItems.push(item);\n            changed = true;\n          }\n        });\n        if (changed) {\n          await chrome.storage.local.set({ items: localItems });\n          renderAll();\n        }\n        event.target.value = '';\n        alert(`${imported.length} bookmarks imported`);\n      } catch (err) {\n        console.error(err);\n        alert('Failed to import bookmarks: ' + err.message);\n      }\n    });\n  }\n",
  30 |     "description": "Add handlers to export bookmarks as a JSON file and import a backup file into local storage.",
  31 |     "feature": "import-export"
  32 |   },
  33 |   {
  34 |     "file": "gallery.html",
  35 |     "action": "insert_after",
  36 |     "anchor": "<button id=\"clear-all\"",
  37 |     "content": "\n    <button id=\"export-btn\" title=\"Export bookmarks\">Export</button>\n    <input id=\"import-btn\" type=\"file\" accept=\"application/json\" title=\"Import bookmarks\" />\n",
  38 |     "description": "Add Export and Import controls to the gallery actions bar.",
  39 |     "feature": "import-export"
  40 |   }
  41 | ]
]]></file>
  </files>

</codebase>